ASSIGNMENT 5
1)​ Deploy postgres Database with adminer on k8s cluster having one master and one worker
node
ANSWER=>
->minikube stop
->minikube delete --all
->minikube start --driver=docker
->kubectl config current-context
->kubectl get nodes
->nano postgres-deployment.yaml
->paste
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15
          env:
            - name: POSTGRES_DB
              value: mydb
            - name: POSTGRES_USER
              value: myuser
            - name: POSTGRES_PASSWORD
              value: mypassword
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: postgres-storage
              mountPath: /var/lib/postgresql/data
      volumes:
        - name: postgres-storage
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
    - port: 5432
      targetPort: 5432
  type: ClusterIP



->kubectl apply -f postgres-deployment.yaml
->kubectl get pods
->nano adminer-deployment.yaml
paste->
apiVersion: apps/v1
kind: Deployment
metadata:
  name: adminer
spec:
  replicas: 1
  selector:
    matchLabels:
      app: adminer
  template:
    metadata:
      labels:
        app: adminer
    spec:
      containers:
        - name: adminer
          image: adminer
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: adminer-service
spec:
  selector:
    app: adminer
  ports:
    - port: 8080
      targetPort: 8080
  type: NodePort

->kubectl apply -f adminer-deployment.yaml
->kubectl get pods
->kubectl get pods -w
->minikube service adminer-service
->Field	Value
System-	PostgreSQL
Server	-postgres-service (this is correct)
Username-	postgres
Password-	password
Database	leave blank or postgres
->say login






2)1.​ Deploy a two-tier application, including a PostgreSQL database and a Go API on k8s.
=>
->kubectl get nodes
->kubectl create namespace two-tier-app
->kubectl get ns
->kubectl create secret generic postgres-secret \
  --namespace=two-tier-app \
  --from-literal=POSTGRES_USER=postgres \
  --from-literal=POSTGRES_PASSWORD=password \
  --from-literal=POSTGRES_DB=testdb

->kubectl get secrets -n two-tier-app
->nano postgres-pvc.yaml
paste->
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: two-tier-app
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

->kubectl apply -f postgres-pvc.yaml
->kubectl get pvc -n two-tier-app
->nano postgres-deployment.yaml
paste->
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: two-tier-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_DB
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: two-tier-app
spec:
  type: ClusterIP
  selector:
    app: postgres
  ports:
    - port: 5432
      targetPort: 5432


->kubectl apply -f postgres-deployment.yaml
->kubectl get pods -n two-tier-app
->kubectl get svc -n two-tier-app

->mkdir ~/go-api
->cd ~/go-api
->nano main.go
paste->
package main

import (
        "fmt"
        "net/http"
)

func main() {
        http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
                fmt.Fprintln(w, `{"status":"ok","db":"connected"}`)
        })

        fmt.Println("Server running on port 8080")
        http.ListenAndServe(":8080", nil)
}

->go mod init go-api

->nano Dockerfile
paste->
FROM golang:1.21-alpine
WORKDIR /app
COPY go.mod ./
RUN go mod tidy
COPY main.go ./
RUN go build -o app
EXPOSE 8080
CMD ["./app"]


->docker build -t siddhi5/go-api:1.0 .
->docker push siddhi5/go-api:1.0
->nano go-api-deployment.yaml
paste->
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go-api
  namespace: two-tier-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: go-api
  template:
    metadata:
      labels:
        app: go-api
    spec:
      containers:
      - name: go-api
        image: siddhi5/go-api:1.0
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: go-api-service
  namespace: two-tier-app
spec:
  type: NodePort
  selector:
    app: go-api
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30080


->kubectl apply -f go-api-deployment.yaml
->kubectl get pods -n two-tier-app
->kubectl get svc -n two-tier-app
->kubectl get nodes -o wide
->minikube ip
->curl http://<IP OF WORKER NODE>:30080/health




